{"data": [{"content": "# Decodable\n\nWeather, emails, social media updates, ... \n\nInformation is ubiquitous in the age of technology, and our mobile devices are an innovative ways to spread data. Most of our mobile applications nowadays are connected to at least one Backend Server. This can be as a mean process data and synchronize them accross your personal devices (Evernote, OneNote, Google Keep, etc.), or this can serve as a mean to connect people (think Email, Facebook, Youtube, etc.).\n\nAs an iOS developers, we have to deal with the response from our Backend Servers using Apple's SDK for iPhones and iPads. Most of the time, this information is given to us in the form of JSON objects (JavaScript Object Notation).\n\nTo decode JSON data, there are a tedious way, an okay way, and an easy way. Let's walk through each of the methods that can be used to parse JSON.\n\n## Treat JSON as \\[String : Any\\]\n\nAny JSON object has keys and values, therefore we almost instantly think of treating it as a dictionary. To parse `JSON` as dictionary, we use `JsonSerialization` class.\n\n```swift\nlet jsonDictionary = try? JSONSerialization.jsonObject(with: jsonData) as? [String : Any]\n```\n\nHowever, this is a tedious way to parse JSON as it maybe deeply nested and/or contain multiple shallowly nested data. Next, we will take a look at how we can use `Decodable` class to parse JSON\n\n## Simple Decodable\n\nThere are multiple tutorials and documentation about `Decodable` and how to use it online. I will simply summary how to use it, the problem I face while using `Decodable` then the next part will reveal how I solve such problem.\n\nSimply speaking, `Decodable` protocol is a built in way to help us parse structured data more easily. To parse response from our Backend Server, we define an object fitting the JSON description.\n\nFor example, the JSON from our server is as follow\n\n```json\n{ // Data for a user\n  \t\"id\": 1,\n  \t\"name\": \"Bach Le\",\n  \t\"email\": \"ldbach97@gmail.com\"\n}\n```\n\nThe corresponding struct/class to parse data maybe as follow\n\n```swift\nstruct User: Identifiable, Decodable {\n    typealias ID = Int64\n    \n    var id: ID\n    let name: String\n    let email: String\n}\n```\n\nThen parse the data, we use a `JSONDecoder`\n\n```swift\nlet jsonData = ..... // Extract Data object from API response\n\nlet decoder = JSONDecoder()\nlet user = try? decoder.decode(User.self, from: jsonData) // User is optional here\n```\n\nSo far so good?\n\nNot quite.\n\nAs you can see, the property `id` is of type `Int64`. Which means it will fail to parse if our backend server acidentally returns ` { \"id\": \"123\" }` instead of `{ \"id\": 123 }` (Plus there is a greate chance where they consider `Integer` to be terible identifier and switch to `String` altogether. We do not want such change to affect our client code.\n\n### Better Decodable\n\nAs you can see, the problem lies in the type of our `User::id`... You maybe tempted to change the type of our user's ID to `String` and be done with it. Like this:\n\n```swift\nstruct User: Identifiable, Decodable {\n    typealias ID = String\n    \n    var id: ID\n    let name: String\n    let email: String\n}\n```\n\nBut sadly, this cannot parse the original JSON data above...\n\nSo the problem becomes how to define an object that can be used to parse `Number` and `String` (or `Bool` if you need to, but I do not know why you would want that) while keeping the convenience of `Decodable` interface.\n\nI have tried and failed a few times, most of the previous time my solution would not be fully compatible with `Decodable` or it is too complicated to use. Most of those issues are because I tried to implement it in existing codebase where my IDs are `String`. As a result, I wrote complicated generic wrapper around the data class and do crazy stuff, only to realize it cannot be used with objects which are nested or in an array. I avoided create a new String class because I think it would be tedious to replace code in multiple places. However, I try creating a new `String` wrapper class and use it as replacement for `String`, and the solution comes easily.\n\n```swift\nclass DecodableString: Hashable, Comparable, Equatable, Decodable {\n    // Sorting ID is a common functionality\n    static func < (lhs: DecodableString, rhs: DecodableString) -> Bool {\n        return lhs.stringValue < rhs.stringValue\n    }\n    \n    // Comparing ID is also a common functinality\n    static func == (lhs: DecodableString, rhs: DecodableString) -> Bool {\n        return lhs.stringValue == rhs.stringValue\n    }\n    \n    // We want to use it with Identifiable, so it must conform to hashable\n    func hash(into hasher: inout Hasher) {\n        return stringValue.hash(into: &hasher)\n    }\n  \n    let stringValue: String\n    \n  \t// Constructor to create assert object when unit testing\n    init(string: String) {\n        self.stringValue = string\n    }\n    \n    required init(from decoder: Decoder) throws {\n        var result: String?\n       \n        // Decoding order: UInt64, Int64, Double, String\n        result = try? \"\\(decoder.singleValueContainer().decode(UInt64.self))\"\n        result = result ?? (try? \"\\(decoder.singleValueContainer().decode(Int64.self))\")\n        result = result ?? (try? \"\\(decoder.singleValueContainer().decode(Double.self))\")\n        result = result ?? (try? \"\\(decoder.singleValueContainer().decode(String.self))\")\n        \n        if let result = result {\n            stringValue = result\n        } else {\n            let lastCodingKey = decoder.codingPath.last\n            throw ApiError.cannotDecodeData(codingKey: lastCodingKey)\n        }\n    }\n}\n```\n\nAnd to use it as drop in replacement for our User class\n\n```swift\nstruct User: Identifiable, Decodable {\n    typealias ID = DecodableString\n    \n    var id: ID\n    let name: String\n    let email: String\n}\n```\n\nWhen we implement `required init(from decoder: Decoder)`, we instruct the decoder to parse current data into our object. In my `DecodableString` class, this function tells the decoder to sequentially treat this data as `UInt64`, `Int64`, `Double`, then as `String`. If the bytes can be parsed into one of the above type, we convert it to `String` and assign it into our internal `String` object. Otherwise, we raise an error together with the `CodingKey` that are failed to be parsed.\n\nNext, I will show the unit test class to parse data using `DecodableString`. In each test case, I also include a similar model class but use `String` instead of `DecodableString` (and asset `String`-using struct to be `nil`.\n\n```swift\nclass DecodableStringTests: XCTestCase {\n\n    func testCanDecodeUInt64AsDecodableString() {\n        let data = \"\"\"\n        {\n            \"string\": \\(UINT64_MAX)\n        }\n        \"\"\".data(using: .utf8)!\n        \n        let stringFromUInt = (try? JSONDecoder().decode(ModelDecodable.self , from: data))?.stringValue ?? \"\"\n        let nilParseResult = try? JSONDecoder().decode(ModelNotDecodable.self , from: data)\n\n        XCTAssertNil(nilParseResult)\n        XCTAssertEqual(stringFromUInt, \"\\(UINT64_MAX)\")\n    }\n    \n    func testCanDecodeNegativeInt64AsDecodableString() {\n           let data = \"\"\"\n           {\n               \"string\": -123123\n           }\n           \"\"\".data(using: .utf8)!\n           \n           let stringFromInt = (try? JSONDecoder().decode(ModelDecodable.self , from: data))?.stringValue ?? \"\"\n           let nilParseResult = try? JSONDecoder().decode(ModelNotDecodable.self , from: data)\n\n           XCTAssertNil(nilParseResult)\n           XCTAssertEqual(stringFromInt, \"-123123\")\n       }\n\n    func testCanDecodeDoubleAsDecodableString() {\n        let data = \"\"\"\n        {\n            \"string\": -123.2345\n        }\n        \"\"\".data(using: .utf8)!\n        \n        let stringFromDouble = (try? JSONDecoder().decode(ModelDecodable.self , from: data))?.stringValue ?? \"\"\n        let nilParseResult = try? JSONDecoder().decode(ModelNotDecodable.self , from: data)\n        \n        XCTAssertNil(nilParseResult)\n        XCTAssertEqual(stringFromDouble, \"-123.2345\")\n    }\n    \n    func testCanDecodeStringAsDecodableString() {\n        let data = \"\"\"\n        {\n            \"string\": \"trivial case\"\n        }\n        \"\"\".data(using: .utf8)!\n        \n        let stringFromString = (try? JSONDecoder().decode(ModelDecodable.self , from: data))?.stringValue ?? \"\"\n        XCTAssertEqual(stringFromString, \"trivial case\")\n    }\n    \n    class ModelDecodable: Decodable {\n        let string: DecodableString\n        \n        var stringValue: String {\n            return string.stringValue\n        }\n    }\n    \n    class ModelNotDecodable: Decodable {\n        let string: String\n    }\n}\n```\n\nYou can take a look at the `BestPractice/` folder, navigate to `BestPractice/BestPracticeUnitTests/DecodableString/` to run test cases related to this article.\n\nThanks for your time. Enjoy your coding journey. Peace.\n"}, {"content": "# Fail Validated Networking\n\nIn a few occasions, some of the field in JSON response from our Backend Server is missing, or invalid. When such events occur, the whole API request fails, rendering the current page with an empty space or ugly error message prompting to reload. As client-side engineer, we should be safe guard our application against such anomaly and try not to interupt the flow of our users. Note that when we handle defects, we do not want to swallow the error. We will have to find a way to notify our Backend Engineers of the problem. If the Backend Server deliver errornous data, telling them details on which field of the response causes the error would accelerate the debuging process.\n\nTo achieve this behavior, we need to separate API logic away from domain logic and add validation mechanism to our API model.\n\n## API Model Separation\n\nIn the previous section, I have introduced a better way to parse string from API calls by introducing a wrapper to Decodable class. However, the solution introduced is not perfect (yet). Because the `DecodableString` class is only helpful as a way to decode a single key as `String`, it is not a good idea to introduce it to our entire codebase (because it is useless and increase boilerplate code when string operation on them is needed). \n\nAs a result, we contain all usage `DecodableString` inside network model only. With this approach, we create two separate models. (I intentionally make the API model name ugly to discourage its use anywhere else.)\n\n```swift\n// For parsing API\nstruct API_User: Decodable {\n    private let id: DecodableString\n    private let name: String\n    private let email: String\n  \n    var domainUser: User {\n      return User(id: id.stringValue, name: name, email: email)\n    }\n}\n\n// For domain usage\nstruct User: Identifiable {\n    typealias ID = String\n    \n    var id: ID\n    let name: String\n    let email: String\n}\n```\n\nWith this approach, we can introduce `DecodableString` or any other decodable wrappers in API model without affecting the remaining codebase. One example is to create a validation for URL.\n\n```swift\nclass URLDecodableString {\n   required init(from decoder: Decoder) throws {\n        var result: String?\n        result = result ?? (try? \"\\(decoder.singleValueContainer().decode(String.self))\")\n        \n        if let result = result, url = URL(string: result), url.scheme != nil, url.host != nil {\n            stringValue = result\n        } else {\n            let lastCodingKey = decoder.codingPath.last\n            throw ApiError.cannotDecodeData(codingKey: lastCodingKey)\n        }\n    }\n}\n```\n\n## Fail Validated API Model\n\nNow that we have separated the API model from our domain model, we can introduce default value and implement validation to notify our logging module that API responses fail.\n\nFor example, to introduce default value to our domain model, we can modify our API model as follows:\n\n```swift\n// We replace the use of struct by class because using struct here complicates our\n// testing code. This model is never used outside the scope of parsing API response\n// so it is not neccessary to use struct here.\nclass API_User: Decodable {\n    private lazy var id: String  = {\n        return _id?.stringValue ?? \"Default value\" // This makes no sense by the way\n    }()\n  \n    private lazy var name: String = {\n        return _name ?? \"Default name\"\n    }()\n\n    private lazy var email: String = {\n        return _email ?? \"Default email\"\n    }()\n  \n    private let _id: String\n    private let _name: String\n    private let _email: String\n  \n    var domainUser: User {\n      return User(id: id.stringValue, name: name, email: email)\n    }\n  \n    var isResponseFullyParsable: Bool {\n        return _id != nil && _name != nil && _email != nil\n    }\n  \n    private enum CodingKeys: String, CodingKey {\n        case _id = \"id\"\n        case _name = \"name\"\n        case _email = \"email\"\n    }\n}\n```\n\nWith this implementation, we can figure out which API fails partially, take log it, and then notify our Backend Engineers to diagnose the problem. However, we can do better. With the current implementation we can only log that the API call is failing, but no information about which particular key failed to parse. We can take a step further and do something like this.\n\n```swift\nclass API_User {\n    // Similar for other variables\n    private lazy var email: String {\n        if _email == nil {\n            codingKeysThatFail.append(CodingKeys._email) \n            return \"Default Value\"\n        }\n        return _email ?? \"Default Value\"\n    }\n  \n    var codingKeysThatFail: [CodingKey] = []\n  \n    private lazy var name: String = {\n        return _name ?? \"Default value\"\n    }()\n}\n```\n\nWhen we read the coding key, we can obtain its `stringValue`. When an API [partially] fails, we can send this information to our logger.\n\n```Swift\n// Example log\nfunc performLog(_ data: API_User) {\n    let apiLog = APILog(apiType: .personalFeed, failKeys: data.codingKeysThatFail)\n    APILogger.shared.submitLog(apiLog)\n}\n```\n\nThe downside to this implementation is that we cannot access `codingKeysThatFails` before getting the `domainUser`.\nIf you do access it before accessing `domainUser`, the array would be empty because we construct the coding keys array only when we access id/name/email.\n\nSimple unit test to demo `API_User` class:\n\n```swift\nclass API_UserTests: XCTestCase {\n\n    func testCanDecodeMissingName() {\n        let data = \"\"\"\n        {\n            \"id\": \"user01\",\n            \"email\": \"user01@mail.com\"\n        }\n        \"\"\".data(using: .utf8)!\n        \n        let apiUser = try? JSONDecoder().decode(API_User.self, from: data)\n        \n        XCTAssertNotNil(apiUser)\n\n        XCTAssertFalse(apiUser!.isResponseFullyParsable)\n        \n        let user = apiUser?.domainUser\n        XCTAssertNotNil(user)\n        XCTAssertEqual(user!, User(id: \"user01\", name: \"bachld\", email: \"user01@mail.com\"))\n        XCTAssertTrue(\n            apiUser!.codingKeysThatFails.contains(where: { $0.stringValue == API_User.CodingKeys._name.stringValue })\n        )\n    }\n    \n    func testCanDecodeMissingEmail() {\n        let data = \"\"\"\n        {\n            \"id\": \"user01\",\n            \"name\": \"Bach Le\"\n        }\n        \"\"\".data(using: .utf8)!\n        \n        let apiUser = try? JSONDecoder().decode(API_User.self, from: data)\n        \n        XCTAssertNotNil(apiUser)\n        XCTAssertFalse(apiUser!.isResponseFullyParsable)\n        \n        let user = apiUser?.domainUser\n        XCTAssertNotNil(user)\n        XCTAssertEqual(user!, User(id: \"user01\", name: \"Bach Le\", email: \"bachld@email.com\"))\n        \n        XCTAssertTrue(\n            apiUser!.codingKeysThatFails.contains(where: {\n                return $0.stringValue == API_User.CodingKeys._email.stringValue\n            })\n        )\n    }\n}\n```\n\n"}, {"content": ""}]}